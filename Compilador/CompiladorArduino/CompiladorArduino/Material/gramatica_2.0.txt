ProgArduino -> 
	{ currentContext = GlobalContext } ListaProg

ListaProg ->
	ListaComandosGlobal
	
ListaComandosGlobal ->
	Declaracao |
	If |
	While |
	DoWhile |
	For |
	Switch |
	Atribuicao |
	Funcao |
	ListaComandosGlobal

ListaComandos ->
	DeclaraVar |
	If |
	While |
	DoWhile |
	For |
	Switch |
	Atribuicao |
	Funcao |
	ListaComandos1

Declaracao -> 
	TipoVar id { DecB.tipo = TipoVar.tipo; DecB.idCod = id.cod; } DecB | 
	void id ( { TableSymbol.add(id.cod, id.tipo, StructureType.Function); currentContext = id.cod } DecC
DecB -> 
	; { TableSymbol.add(DecB.idCod, DecB.tipo) } | 
	, { TableSymbol.add(DecB.idCod, DecB.tipo) } id { ListaVar.tipo = DecB.tipo; TableSymbol.add(id.cod, DecB.tipo) } ListaVar | 
	( { TableSymbol.add(DecB.idCod, DecB.tipo, StructureType.Function); currentContext = DecB.idCod } DecC
DecC -> 
	ListaDecParm) {{ ListaComandos Retorno }} { currentContext = GlobalContext }
Retorno -> 
	return Exp ; | 
	""

ListaDecParm -> 
	TipoVar id { TableSymbol.add(id.cod, TipoVar.tipo, currentContext) } ListaDecParmB | 
	""
ListaDecParmB -> 
	, TipoVar id { TableSymbol.add(id.cod, TipoVar.tipo, currentContext) } ListaDecParmB1 | 
	""

ListaVar -> 
	, id { ListaVar1.tipo = TipoVar.tipo; TableSymbol.add(id.cod, ListaVar.tipo, currentContext) } ListaVar1 |
	""

DeclaraVar ->
	TipoVar id { ListaVar.tipo = TipoVar.tipo; TableSymbol.add(id.cod, ListaVar.tipo, currentContext) } ListaVar;

TipoVar ->
	int | { TipoVar.tipo = "int" }
	long | { TipoVar.tipo = "long" }
	float | { TipoVar.tipo = "float" }
	bool | { TipoVar.tipo = "bool" }
	byte //REMOVER

Atribuicao -> 
	id { TableSymbol.ExistsVar(id.cod); AtribOp.id = id.cod } AtribOp { Atribuicao.cod = AtribOp.cod }
AtribOp ->
	= Exp  | { AtribOp.cod = Exp.cod || gen(=, AtribOp.id, Exp.place) }
	+= Exp | { AtribOp.place = criatemp(); AtribOp.cod = Exp.cod || 
				gen(+, AtribOp.place, AtribOp.id, Exp.place) || gen(=, AtribOp.id, AtribOp.place) }
	-= Exp | { AtribOp.place = criatemp(); AtribOp.cod = Exp.cod || 
				gen(-, AtribOp.place, AtribOp.id, Exp.place) || gen(=, AtribOp.id, AtribOp.place) }
	*= Exp | { AtribOp.place = criatemp(); AtribOp.cod = Exp.cod || 
				gen(*, AtribOp.place, AtribOp.id, Exp.place) || gen(=, AtribOp.id, AtribOp.place) }
	/= Exp   { AtribOp.place = criatemp(); AtribOp.cod = Exp.cod || 
				gen(/, AtribOp.place, AtribOp.id, Exp.place) || gen(=, AtribOp.id, AtribOp.place) }

------------
TESTE
Exp -> { R.htrue = E.true; R.hfalse = E.false; T.true = E.true; Lb = geralabel(); T.false = Lb???E.false???; } T { 
	R.hc = T.cod; R.hp = T.place; R.ht = T.tipo; R.Lb = Lb?? } R { E.cod = R.sc; E.place = R.sp; E.tipo = R.st }
R -> { R1.htrue = R.htrue; R1.hfalse = R.hfalse } || { T.true = R.htrue; Lb = geralabel(); T.false = Lb } T { 
	if(R.htrue != null){ R1.hc = R.hc || gen(Lb??R.Lb???, ':') || T.cod; }
	else{ R1.hp = criatemp(); R1.hc = R.hc || T.cod || gen(||, R1.hp, R.hp, T.place); }
	R1.ht = geratipo(||, R.ht, T.tipo);
	} R1 { R.sc = R1.sc; R.sp = R1.sp; R.st = R1.st }
R -> Ɛ { R.sc = R.hc; R.sp = R1.sp; R.st = R1.st }

//teste 2
Exp -> {Rhtrue=E.true; Rhfalse=geralabel(); T.true??} T {
	Rhc=T.cod; Rhp=T.place; Rht=T.tipo} R {E.cod=Rsc; E.place=Rsp; E.tipo=Rst}
R -> {R1htrue=Rhtrue; R1hfalse=Rhfalse} || {T.true=Rhtrue; T.false=Rhfalse} T {
	if(Rhtrue!=null){ R1hc=Rhc || gen(Rhfalse,':') || T.cod; }
	else{ R1hp=criatemp(); R1hc=Rhc || T.cod || gen(||, R1hp, Rhp, T.place); }
	R1ht=geratipo(||, Rht, T.tipo);
	} R1 { R.sc = R1.sc; R.sp = R1.sp; R.st = R1.st }
R -> Ɛ { R.sc = R.hc; R.sp = R1.sp; R.st = R1.st }
------------

Exp -> T R
R -> || T R1
R -> Ɛ

T -> F U
U -> && F U1
U -> Ɛ

F -> G
G -> !G

--G -> H1 > H2  { G.place = criatemp(); G.cod = H1.cod || H2.cod || gen(>, G.place, H1.place, H2.place); G.tipo = TableSymbol.CalcType(>, H1.tipo, H2.tipo);
		if(G.true != null) G.cod += gen("if", G.place, "!= 0 goto", G.true) || gen("goto", G.false); }

G -> H { V.hc = H.cod; V.hp = H.place; V.ht = H.tipo } V { G.cod = V.sc; G.place = V.sp; G.tipo = V.st }
V -> > H { V1.hp = criatemp(); V1.hc = V.hc || H.cod || gen(>, V1.hp, V.hp, H.place);
			V1.ht = TableSymbol.CalcType(>, V.ht, H.tipo) } V1 { V.sp = V1.sp; V.sc = V1.sc; V.st = V1.st }
V -> == H { V1.hp = criatemp(); V1.hc = V.hc || H.cod || gen(==, V1.hp, V.hp, H.place);
			V1.ht = TableSymbol.CalcType(==, V.ht, H.tipo) } V1 { V.sp = V1.sp; V.sc = V1.sc; V.st = V1.st }
V -> < H { V1.hp = criatemp(); V1.hc = V.hc || H.cod || gen(<, V1.hp, V.hp, H.place);
			V1.ht = TableSymbol.CalcType(<, V.ht, H.tipo) } V1 { V.sp = V1.sp; V.sc = V1.sc; V.st = V1.st }
V -> >= H { V1.hp = criatemp(); V1.hc = V.hc || H.cod || gen(>=, V1.hp, V.hp, H.place);
			V1.ht = TableSymbol.CalcType(>=, V.ht, H.tipo) } V1 { V.sp = V1.sp; V.sc = V1.sc; V.st = V1.st }
V -> != H { V1.hp = criatemp(); V1.hc = V.hc || H.cod || gen(!=, V1.hp, V.hp, H.place);
			V1.ht = TableSymbol.CalcType(!=, V.ht, H.tipo) } V1 { V.sp = V1.sp; V.sc = V1.sc; V.st = V1.st }
V -> <= H { V1.hp = criatemp(); V1.hc = V.hc || H.cod || gen(<=, V1.hp, V.hp, H.place);
			V1.ht = TableSymbol.CalcType(<=, V.ht, H.tipo) } V1 { V.sp = V1.sp; V.sc = V1.sc; V.st = V1.st }
V -> Ɛ { V.sp = V.hp; V.sc = V.hc; V.st = V.ht }

H -> J { X.hc = J.cod; X.hp = J.place; X.ht = J.tipo } X { H.cod = X.sc; H.place = X.sp; H.tipo = X.st;
--		if(H.true != null && J.place == X.sp???) H.cod += gen("if", H.place, "!= 0 goto", H.true) || gen("goto", H.false); }
X -> + J { X1.hp = criatemp(); X1.hc = X.hc || J.cod || gen(+, X1.hp, X.hp, J.place); 
			X1.ht = TableSymbol.CalcType(+, X.ht, J.tipo) } X1 { X.sp = X1.sp; X.sc = X1.sc; X.st = X1.st }
X -> - J { X1.hp = criatemp(); X1.hc = X.hc || J.cod || gen(-, X1.hp, X.hp, J.place); 
			X1.ht = TableSymbol.CalcType(-, X.ht, J.tipo) } X1 { X.sp = X1.sp; X.sc = X1.sc; X.st = X1.st }
X -> Ɛ { X.sp = X.hp; X.sc = X.hc; X.st = X.ht }

J -> K { Y.hc = K.cod; Y.hp = K.place; Y.ht = K.tipo } Y { J.cod = Y.sc; J.place = Y.sp; J.tipo = Y.st }
Y -> * K { Y1.hp = criatemp(); T1.hc = Y.hc | K.cod || gen(*, Y1.hp, Y.hp, K.place);
			Y1.ht = TableSymbol.CalcType(*, Y.ht, K.tipo) } Y1 { Y.sp = Y1.sp; Y.sc = Y1.sc; Y.st = Y1.st }
Y -> / K { Y1.hp = criatemp(); T1.hc = Y.hc || K.cod || gen(/, Y1.hp, Y.hp, K.place);
			Y1.ht = TableSymbol.CalcType(/, Y.ht, K.tipo) } Y1 { Y.sp = Y1.sp; Y.sc = Y1.sc; Y.st = Y1.st }
Y -> % K { Y1.hp = criatemp(); T1.hc = Y.hc || K.cod || gen(%, Y1.hp, Y.hp, K.place);
			Y1.ht = TableSymbol.CalcType(%, Y.ht, K.tipo) } Y1 { Y.sp = Y1.sp; Y.sc = Y1.sc; Y.st = Y1.st }
Y -> Ɛ { Y.sp = Y.hp; Y.sc = Y.hc; Y.st = Y.ht }

K ->
	id |    { K.place = id.cod; K.cod = ""; TableSymbol.Exists(id.cod); K.tipo = TableSymbol.getType(id.cod);
				if(K.tipo == "bool") K.cod = gen("if", K.place, "== true goto", K.true) || gen("goto", K.false); }
	(E) |   { K.place = E.place; K.cod = E.cod; K.tipo = E.tipo; 
				E.true = K.true; E.false = K.false; }
	cteint | { K.place = criatemp(); K.cod = gen(=, K.place, cte.val); K.tipo = "int"; 
				if(K.place != 0) K.cod = gen("goto", K.true); else K.cod = gen("goto", K.false); }
	ctelong | { K.place = criatemp(); K.cod = gen(=, K.place, cte.val); K.tipo = "long"; 
				if(K.place != 0) K.cod = gen("goto", K.true); else K.cod = gen("goto", K.false); }
	ctefloat |{ K.place = criatemp(); K.cod = gen(=, K.place, cte.val); K.tipo = "float"; 
				if(K.place != 0) K.cod = gen("goto", K.true); else K.cod = gen("goto", K.false); }
	ctebool | { K.place = criatemp(); K.cod = gen(=, K.place, cte.val); K.tipo = "bool";
				if (cte.val == true) K.cod = gen("goto", K.true); else K.cod = gen("goto", K.false); }
	Funcao

If ->
	if ( { LIni = geralabel(); LElse = geralabel(); LFim = geralabel(); Exp.true = LIf; Exp.false = LElse } Exp ) 
		{{ ListaComandos }} { IfEnd.LElse = LElse } IfEnd { 
			If.cod = Exp.cod || gen(LIf, ':') || ListaComandos.cod || IfEnd.cod }
IfEnd ->
	else {{ ListaComandos }} | { IfEnd.cod = gen(IfEnd.LElse, ':') || ListaComandos.cod }
	else If | { IfEnd.cod = gen(IfEnd.LElse, ':') || If.cod }
	"" { IfEnd.cod = "" }

--falta short circuit nos loops
While ->
	while { LIni = geralabel(); LFim = geralabel(); } ( Exp ) {{ { LoopCom.LIni = LIni; LoopCom.LFim = LFim } LoopCom }} 
		{ While.cod = gen(LIni, ':') || Exp.cod || gen("if", Exp.place, "= 0", "goto", LFim) 
		|| LoopCom.cod || gen("goto", LIni) || gen(LFim, ':') }

DoWhile ->
	do {{ { LIni = geralabel(); LFim = geralabel(); LoopCom.LIni = LIni; LoopCom.LFim = LFim } LoopCom }} while ( Exp ); 
		{ DoWhile.cod = gen(LIni, ':') || LoopCom.cod || Exp.cod || gen("if", Exp.place, "= 0", "goto", LFim)
		|| gen("goto", LIni) || gen(LFim, ':') }

For ->
	for { LIni = geralabel(); LFim = geralabel(); } ( ListaAtrib1; Exp; ListaAtrib2 ) 
		{{ { LoopCom.LIni = LIni; LoopCom.LFim = LFim } LoopCom }}
		{ For.cod = ListaAtrib1.cod || gen(LIni, ':') || Exp.cod || gen("if", Exp.place, "= 0", "goto", LFim)
		|| LoopCom.cod || ListaAtrib2.cod || gen("goto", LIni) || gen(LFim, ':') }
ListaAtrib ->
	Atribuicao ListaAtribA { ListaAtrib.cod = Atribuicao.cod || ListaAtribA.cod }
ListaAtribA ->
	, Atribuicao ListaAtribA | { ListaAtribA.cod = gen(',') || Atribuicao.cod || ListaAtribA.cod }
	"" { ListaAtribA.cod = "" }

LoopCom ->
	break | { LoopCom.cod = gen("goto", LoopCom.LFim) }
	continue | { LoopCom.cod = gen("goto", LoopCom.LIni) }
	ListaComandos { LoopCom.cod = ListaComandos.cod }

Funcao ->
	id ( { TableSymbol.ExistsFunction(id.cod) } ListaParam );
	id.id ( ListaParam  ); // REMOVER?
ListaParam -> 
	Exp ListaParamRec | 
	""
ListaParamRec -> 
	, Exp ListaParamRec | 
	""
	
//REMOVER
Switch ->
	switch ( Exp ) {{ ListaCase SwitchDefault }}
ListaCase ->
	case const_int : {{ ListaComandos CaseEnd |
	ListaCase |
	""
CaseEnd ->
	}} break; |
	}}
SwitchDefault ->
	default: {{ ListaComandos CaseEnd |
	""


// Duvidas
-Separar blocos de comandos dos loops, if e funcao {}? nao precisa
-Como fazer verificacao de tipo na atribuicao? float pode ser atribuido para int
-Adicionar atribuicao com operadores reduzidos(+= *= ...)? fazer
-Como fica exp de id = 1 || 2 ? tratar como int
-boolean em c nao existe, como tratar?
-como fica operadores ! ?
-goto no && e ||